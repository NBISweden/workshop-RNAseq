<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Preprocessing</title>
    <meta charset="utf-8" />
    <meta name="author" content="Roy Francis | 30-Nov-2020" />
    <meta name="keywords" content="bioinformatics, course, scilifelab, nbis" />
    <link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
    <link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
    <link id="font-awesome-1-attachment" rel="attachment" href="site_libs/font-awesome-5.1.0/fonts/fontawesome-webfont.ttf"/>
    <link rel="stylesheet" href="assets/slide.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Data Preprocessing
## Workshop on RNA-Seq
### <b>Roy Francis</b> | 30-Nov-2020
### NBIS, SciLifeLab

---

exclude: true
count: false


&lt;link href="https://fonts.googleapis.com/css?family=Roboto|Source+Sans+Pro:300,400,600|Ubuntu+Mono&amp;amp;subset=latin-ext" rel="stylesheet"&gt;
&lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"&gt;





&lt;!-- ------------ Only edit title, subtitle &amp; author above this ------------ --&gt;



---
name: raw

## Raw data

- Raw count table


```
##                    DSSd00_1 DSSd00_2 DSSd00_3 DSSd07_1 DSSd07_2 DSSd07_3
## ENSMUSG00000102693        0        0        0        0        0        0
## ENSMUSG00000064842        0        0        0        0        0        0
## ENSMUSG00000051951        0        1        2        0        3        2
## ENSMUSG00000102851        0        0        0        0        0        0
## ENSMUSG00000103377        0        0        0        0        0        0
## ENSMUSG00000104017        0        0        0        0        0        0
```

- Metadata


```
##          SampleName     SampleID No Model Day Group Replicate
## DSSd00_1   DSSd00_1 KI_PC1606_01  1   DSS   0 day00         1
## DSSd00_2   DSSd00_2 KI_PC1606_02  2   DSS   0 day00         2
## DSSd00_3   DSSd00_3 KI_PC1606_03  3   DSS   0 day00         3
## DSSd07_1   DSSd07_1 KI_PC1606_13 13   DSS   7 day07         1
## DSSd07_2   DSSd07_2 KI_PC1606_14 14   DSS   7 day07         2
## DSSd07_3   DSSd07_3 KI_PC1606_15 15   DSS   7 day07         3
```

???

A glimpse into the count table and metadata table. It is important to make sure before any analyses that the count column names match the metadata row names perfectly. Make sure the column in both tables are of the correct data type; ie; numbers are numeric and groups are factors.

---
name: pp

## Preprocessing

- Remove genes and samples with low counts


```r
cf1 &lt;- cr[rowSums(cr&gt;0) &gt;= 2, ]
cf2 &lt;- cr[rowSums(cr&gt;3) &gt;= 2, ]
cf3 &lt;- cr[rowSums(edgeR::cpm(cr)&gt;1) &gt;= 2, ]
```

- Inspect distribution

&lt;img src="slide_preprocessing_files/figure-html/unnamed-chunk-6-1.svg" style="display: block; margin: auto auto auto 0;" /&gt;

- Inspect the number of rows (genes)


```
## Raw: 55487, Method 1: 17529, Method 2: 12481, Method 3: 17529
```

???

Lowly expressed genes are removed to improve the signal-to-noise ratio. Genes not expressed in any sample can be removed completely as as they negatively affect multiple testing correction. The stringency of low count filtering can be adjusted based on the researcher's preference. It is a tradeoff between data quality vs data size.

In the above example, raw data has a huge number of zeros and the distribution of over higher value counts are barely visible. Three different levels of low count filtering are shown.

In method 1, the detection limit is set at 1 count, ie; any value above 0 is considered as an expressed gene. And we aim to have expression in atleast 2 samples.

In method 2, the detection limit is set at 5 counts, ie; any value above 5 is considered an expressed gene. A value below 5 is considered noise and is disregarded. And we aim to have 5 count expression in atleast 2 samples. Note that changing the minimum limit of detection has a dramatic effect on the count distribution. Notice how many rows (genes) are discarded.

In method 3, the limit of detection is a bit less subjective. A count that is greater than 1 count per million reads is considered a positive detection. This is the most stringent method at the expense of losing the most number of genes.

---
name: norm-1

## Normalisation

.pull-left-50[
- Make counts comparable across samples
- Control for sequencing depth

![](data/normalization_methods_depth.png)


```
##    A B A_tc B_tc
## x 20 6  Inf  Inf
## y 25 6  Inf  Inf
## z 15 4  Inf  Inf
```
]

???

Normalisation of raw count data is necessary to make samples comparable. The comparison may be within sample, within groups, between groups and possibly between studies.

**Total count normalisation**

Imagine two samples A and B with three genes x, y and z. A has higher counts than B. Are the genes highly expressed in A? Probably not. A was sequenced deeper which resulted in more reads overall. Controlling for sequencing depth is one of the the first steps with normalisation. Total count normalisation controls for sequencing depth. See columns A_tc and B_tc for the count values after total count normalisation. If the total number of starting mRNA is comparable between samples, then this value reflects absolute expression for each gene.

Quantile normalisation, Upper quartile normalisation and Median normalisation all work in a similar way. Rather than the total count, a high quantile value or the median is used.

--

.pull-right-50[
- Control for compositional bias
![](data/normalization_methods_composition.png)


```
##      A  B A_tc B_tc
## x    0 20  NaN  Inf
## y   25 25  Inf  Inf
## z   15  4  Inf  Inf
## de 100  2  Inf  Inf
```
]

???

**Controlling for compositional bias**

In another scenario, imagine the same two samples and four genes x,y,z and de. This time, both samples are sequenced to the same depth and the gene de is highly overexpressed in A than in B. Now, look at the total count normalised value for gene y. They have different normalised values in A and B although A and B had identical expression for gene y. This effect of few highly overexpressed genes seemingly changing the relative expression of other genes is called compositional bias.

---
name: norm-2

## Normalisation

- Make counts comparable across features (genes)
.size-60[![](data/normalization_methods_length.png)]


```
##   counts gene_length norm_counts
## x     50          10           5
## y     25           5           5
```

--

- Bring counts to a human-friendly scale

???

**Controlling for gene length**

For two genes X and Y within a sample A, the longer gene will produce more reads than the shorter gene. For comparing expression of these two genes to each other, they need to be controlled for gene length.

In this example, gene x has higher counts than y. But when controlled for gene length, they both have the same expression.

**Counts per million reads**

The last point with normalisation is to bring the numbers to a human friendly scale. This the reason for the per million part of CPM, RPKM etc. 

---
name: norm-3a

## Normalisation

**Normalisation by library size**

- Assumes total expression is the same under different experimental conditions
- Methods include TC, RPKM, FPKM, TPM
- RPKM, FPKM and TPM control for sequencing depth and gene length
- TPM enables better comparison between samples and between experiments

--

**Normalisation by distribution**

- Assumes technical effects are same for DE and non-DE genes
- Assumes number of over and under-expressed genes are roughly same across conditions
- Corrects for compositional bias
- Methods include Q, UQ, M, RLE, TMM, MRN
- `edgeR::calcNormFactors()` implements TMM, TMMwzp, RLE &amp; UQ
- `DESeq2::estimateSizeFactors()` implements median ratio method (RLE)
- Does not correct for gene length
- **[geTMM](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2246-7)** is gene length corrected TMM

.citation[
.cite[&lt;i class="fas fa-link"&gt;&lt;/i&gt; Evans, Ciaran, Johanna Hardin, and Daniel M. Stoebel. "Selecting between-sample RNA-Seq normalization methods from the perspective of their assumptions." [Briefings in bioinformatics (2017)](https://arxiv.org/abs/1609.00959)]  
]

???

Normalisation strategies can be roughly grouped into four approaches: Normalisation by library size, normalisation by distribution, normalisation by testing and normalisation using controls.

Normalisation by library size is the most basic. TPM is probably the only method that must be used. Normalisation by distribution controls for composition bias. Most software use a mix of different approaches.

---
name: norm-3b

## Normalisation

**Normalisation by testing**

- A more robust version of normalisation by distribution.
- A set of non-DE genes are detected through hypothesis testing
- Tolerates a larger difference in number of over and under expressed genes between conditions
- Methods include PoissonSeq, DEGES

--

**Normalisation using Controls**

- Assumes controls are not affected by experimental condition and technical effects are similar to all other genes
- Useful in conditions with global shift in expression
- Controls could be house-keeping genes or spike-ins
- Methods include RUV, CLS

--

**Stabilizing variance**
- Variance is stabilised across the range of mean values
- Mwthods include VST, RLOG, VOOM
- For use in exploratory analyses. Not for DE.
- `vst()` and `rlog()` functions from *DESeq2*
- `voom()` function from *Limma* converts data to normal distribution

---
name: norm-4

## Normalisation

**Recommendations**

- Most tools use a mix of many different normalisations
- For DGE using DGE R packages (DESeq2, edgeR, Limma etc), use raw counts
- For visualisation (PCA, clustering, heatmaps etc), use VST or RLOG
- For own analysis with gene length correction, use TPM (maybe geTMM?)
- Custom solutions: spike-ins/house-keeping genes

--



&lt;img src="slide_preprocessing_files/figure-html/unnamed-chunk-12-1.svg" style="display: block; margin: auto auto auto 0;" /&gt;

&lt;img src="slide_preprocessing_files/figure-html/unnamed-chunk-13-1.svg" style="display: block; margin: auto auto auto 0;" /&gt;

.citation[
.cite[&lt;i class="fas fa-link"&gt;&lt;/i&gt; Dillies, Marie-Agnes, *et al*. "A comprehensive evaluation of normalization methods for Illumina high-throughput RNA sequencing data analysis." [Briefings in bioinformatics 14.6 (2013): 671-683](https://www.ncbi.nlm.nih.gov/pubmed/22988256)]
]

---
name: eda-cor

## Exploratory | Correlation

- Correlation between samples


```r
dmat &lt;- as.matrix(cor(cv,method="spearman"))
pheatmap::pheatmap(dmat,border_color=NA,annotation_col=mr[,"Group",drop=F],
         annotation_row=mr[,"Group",drop=F],annotation_legend=T)
```

&lt;img src="slide_preprocessing_files/figure-html/unnamed-chunk-14-1.svg" style="display: block; margin: auto auto auto 0;" /&gt;

---
name: eda-dist

## Exploratory | Distance

- Similarity between samples


```r
dmat &lt;- as.matrix(dist(t(cv)))
pheatmap(dmat,border_color=NA,annotation_col=mr[,"Group",drop=F],
         annotation_row=mr[,"Group",drop=F],annotation_legend=T)
```

&lt;img src="slide_preprocessing_files/figure-html/unnamed-chunk-15-1.svg" style="display: block; margin: auto auto auto 0;" /&gt;

---
name: eda-pca

## Exploratory | PCA

- Relationship between samples

.pull-left-40[
&lt;img src="slide_preprocessing_files/figure-html/unnamed-chunk-16-1.svg" style="display: block; margin: auto auto auto 0;" /&gt;
]

.pull-right-60[
&lt;img src="slide_preprocessing_files/figure-html/unnamed-chunk-17-1.svg" style="display: block; margin: auto auto auto 0;" /&gt;



]

---

# Acknowledgements

- [Normalising RNA-seq data](https://www.ebi.ac.uk/sites/ebi.ac.uk/files/content.ebi.ac.uk/materials/2012/121029_HTS/ernest_turro_normalising_rna-seq_data.pdf) by Ernest Turro  
- RNA-seq analysis [Bioconductor vignette](http://master.bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html)

---
name: end_slide
class: end-slide, middle
count: false

# Thank you. Questions?



.end-text[
&lt;p&gt;R version 4.0.3 (2020-10-10)&lt;br&gt;&lt;p&gt;Platform: x86_64-pc-linux-gnu (64-bit)&lt;/p&gt;&lt;p&gt;OS: Ubuntu 18.04.5 LTS&lt;/p&gt;&lt;br&gt;

&lt;hr&gt;

&lt;span class="small"&gt;Built on : &lt;i class='fa fa-calendar' aria-hidden='true'&gt;&lt;/i&gt; 30-Nov-2020 at &lt;i class='fa fa-clock-o' aria-hidden='true'&gt;&lt;/i&gt; 16:44:23&lt;/span&gt;  

&lt;b&gt;2020&lt;/b&gt; • [SciLifeLab](https://www.scilifelab.se/) • [NBIS](https://nbis.se/)
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="assets/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "4:3",
"highlightLanguage": "r",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"slideNumberFormat": "%current%/%total%"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
