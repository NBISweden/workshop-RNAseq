<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Data preprocessing</title>

<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
<link id="font-awesome-1-attachment" rel="attachment" href="site_libs/font-awesome-5.1.0/fonts/fontawesome-webfont.ttf"/>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="assets/lab.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
#TOC {
  display: none !important;
}
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div id="header">






</div>


<!-- rmd lab header -->
<p><br></p>
<div class="boxy boxy-exclamation boxy-yellow">
<p>Set <code>~/RNAseq/labs/</code> as your working directory (i.e.Â your working directory should be the directory where you saved this .Rmd file). Create a subdirectory named <code>data</code> in this directory (<code>~/RNAseq/labs/data/</code>) for input and output files.</p>
</div>
<p>Data preprocessing is done in R. Load the necessary R packages and source the download function.</p>
<pre class="r"><code># plotting
library(DESeq2) # rna-seq
library(stringr)
library(rafalib) # nice plot arrangement
rafalib::mypar(mar=c(6,2.5,2.5,1)) #sets nice arrangement for the whole document

# source download function
source(&quot;https://raw.githubusercontent.com/NBISweden/workshop-RNAseq/master/assets/scripts.R&quot;)</code></pre>
<p><br></p>
<div id="preparation" class="section level1">
<h1><span class="header-section-number">1</span> Preparation</h1>
<p>The first step is some data wrangling and clean-up to prepare the data for analyses. Download the count table generated by featureCounts (named <strong>gene_counts_original.tsv</strong> in the repository) into the <code>data</code> subdirectory.</p>
<pre class="r"><code>download_data(&quot;data/gene_counts_original.tsv&quot;)</code></pre>
<p>Download the metadata table.</p>
<pre class="r"><code>download_data(&quot;data/metadata_original.csv&quot;)</code></pre>
<p>Read in the files to R.</p>
<pre class="r"><code>co &lt;- read.delim(&quot;data/gene_counts_original.tsv&quot;,
                 sep = &quot;\t&quot;,
                 header = TRUE,
                 stringsAsFactors = FALSE,
                 comment.char = &quot;#&quot;)
mo &lt;- read.csv(&quot;data/metadata_original.csv&quot;,
               header = TRUE)</code></pre>
<p>Inspect how the files look like.</p>
<pre class="r"><code>head(co)
head(mo)</code></pre>
<pre><code>##               Geneid           Chr
## 1 ENSMUSG00000102693             1
## 2 ENSMUSG00000064842             1
## 3 ENSMUSG00000051951 1;1;1;1;1;1;1
## 4 ENSMUSG00000102851             1
## 5 ENSMUSG00000103377             1
## 6 ENSMUSG00000104017             1
##                                                     Start
## 1                                                 3073253
## 2                                                 3102016
## 3 3205901;3206523;3213439;3213609;3214482;3421702;3670552
## 4                                                 3252757
## 5                                                 3365731
## 6                                                 3375556
##                                                       End        Strand Length
## 1                                                 3074322             +   1070
## 2                                                 3102125             +    110
## 3 3207317;3207317;3215632;3216344;3216968;3421901;3671498 -;-;-;-;-;-;-   6094
## 4                                                 3253236             +    480
## 5                                                 3368549             -   2819
## 6                                                 3377788             -   2233
##   hisat2_results.subset_1M_reads.KI_PC1606_01.bam
## 1                                               0
## 2                                               0
## 3                                               0
## 4                                               0
## 5                                               0
## 6                                               0
##   hisat2_results.subset_1M_reads.KI_PC1606_02.bam
## 1                                               0
## 2                                               0
## 3                                               1
## 4                                               0
## 5                                               0
## 6                                               0
##   hisat2_results.subset_1M_reads.KI_PC1606_03.bam
## 1                                               0
## 2                                               0
## 3                                               2
## 4                                               0
## 5                                               0
## 6                                               0
##   hisat2_results.subset_1M_reads.KI_PC1606_13.bam
## 1                                               0
## 2                                               0
## 3                                               0
## 4                                               0
## 5                                               0
## 6                                               0
##   hisat2_results.subset_1M_reads.KI_PC1606_14.bam
## 1                                               0
## 2                                               0
## 3                                               3
## 4                                               0
## 5                                               0
## 6                                               0
##   hisat2_results.subset_1M_reads.KI_PC1606_15.bam
## 1                                               0
## 2                                               0
## 3                                               2
## 4                                               0
## 5                                               0
## 6                                               0
##   SampleName     SampleID No Model Day Group Replicate
## 1   DSSd00_1 KI_PC1606_01  1   DSS   0 day00         1
## 2   DSSd00_2 KI_PC1606_02  2   DSS   0 day00         2
## 3   DSSd00_3 KI_PC1606_03  3   DSS   0 day00         3
## 4   DSSd02_1 KI_PC1606_04  4   DSS   2 day02         1
## 5   DSSd02_2 KI_PC1606_05  5   DSS   2 day02         2
## 6   DSSd02_3 KI_PC1606_06  6   DSS   2 day02         3</code></pre>
<p>We need the count table to have only the counts (numeric data) with gene IDs as row names. And the metadata table must only include information for the samples that are in the count table. And in the same order.</p>
<pre class="r"><code>cr &lt;- co[,7:12]
rownames(cr) &lt;- co$Geneid
colnames(cr) &lt;- substr(colnames(cr),42,43)
mr &lt;- mo[mo$No %in% as.integer(colnames(cr)),]
colnames(cr) &lt;- mr$SampleName
rownames(mr) &lt;- mr$SampleName</code></pre>
<p>Inspect the new count table and metadata table. Ensure that labels match.</p>
<pre class="r"><code>head(cr)
mr
all.equal(colnames(cr),rownames(mr))</code></pre>
<pre><code>##                    DSSd00_1 DSSd00_2 DSSd00_3 DSSd07_1 DSSd07_2 DSSd07_3
## ENSMUSG00000102693        0        0        0        0        0        0
## ENSMUSG00000064842        0        0        0        0        0        0
## ENSMUSG00000051951        0        1        2        0        3        2
## ENSMUSG00000102851        0        0        0        0        0        0
## ENSMUSG00000103377        0        0        0        0        0        0
## ENSMUSG00000104017        0        0        0        0        0        0
##          SampleName     SampleID No Model Day Group Replicate
## DSSd00_1   DSSd00_1 KI_PC1606_01  1   DSS   0 day00         1
## DSSd00_2   DSSd00_2 KI_PC1606_02  2   DSS   0 day00         2
## DSSd00_3   DSSd00_3 KI_PC1606_03  3   DSS   0 day00         3
## DSSd07_1   DSSd07_1 KI_PC1606_13 13   DSS   7 day07         1
## DSSd07_2   DSSd07_2 KI_PC1606_14 14   DSS   7 day07         2
## DSSd07_3   DSSd07_3 KI_PC1606_15 15   DSS   7 day07         3
## [1] TRUE</code></pre>
<p>Finally save the data in the <strong>data</strong> directory.</p>
<pre class="r"><code>write.csv(cr,file=&quot;data/gene_counts_raw.csv&quot;,quote=FALSE)
write.csv(mr,file=&quot;data/metadata_raw.csv&quot;,quote=FALSE)</code></pre>
</div>
<div id="filtering" class="section level1">
<h1><span class="header-section-number">2</span> Filtering</h1>
<p>The next step is to remove samples and genes that are uninformative. We read in the count table (<em>You can skip this step if continuing from the previous step</em>).</p>
<pre class="r"><code>download_data(&quot;data/gene_counts_raw.csv&quot;)
cr &lt;- read.csv(&quot;data/gene_counts_raw.csv&quot;,
               header = TRUE,
               stringsAsFactors = FALSE,
               row.names = 1)
head(cr)
str(cr)</code></pre>
<pre><code>##                    DSSd00_1 DSSd00_2 DSSd00_3 DSSd07_1 DSSd07_2 DSSd07_3
## ENSMUSG00000102693        0        0        0        0        0        0
## ENSMUSG00000064842        0        0        0        0        0        0
## ENSMUSG00000051951        0        1        2        0        3        2
## ENSMUSG00000102851        0        0        0        0        0        0
## ENSMUSG00000103377        0        0        0        0        0        0
## ENSMUSG00000104017        0        0        0        0        0        0
## &#39;data.frame&#39;:    55487 obs. of  6 variables:
##  $ DSSd00_1: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ DSSd00_2: int  0 0 1 0 0 0 0 0 0 0 ...
##  $ DSSd00_3: int  0 0 2 0 0 0 0 0 0 0 ...
##  $ DSSd07_1: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ DSSd07_2: int  0 0 3 0 0 0 0 0 0 0 ...
##  $ DSSd07_3: int  0 0 2 0 0 0 0 0 0 0 ...</code></pre>
<p>The count data shows read counts across samples and genes. The columns denote samples and rows denote genes.</p>
<p>Read in the metadata (<em>You can skip this step if continuing from the previous step</em>). Each row corresponds to a sample.</p>
<pre class="r"><code>download_data(&quot;data/metadata_raw.csv&quot;)
mr &lt;- read.csv(&quot;data/metadata_raw.csv&quot;,
               header = TRUE,
               stringsAsFactors = FALSE,
               row.names = 1)
head(mr)
str(mr)</code></pre>
<pre><code>##          SampleName     SampleID No Model Day Group Replicate
## DSSd00_1   DSSd00_1 KI_PC1606_01  1   DSS   0 day00         1
## DSSd00_2   DSSd00_2 KI_PC1606_02  2   DSS   0 day00         2
## DSSd00_3   DSSd00_3 KI_PC1606_03  3   DSS   0 day00         3
## DSSd07_1   DSSd07_1 KI_PC1606_13 13   DSS   7 day07         1
## DSSd07_2   DSSd07_2 KI_PC1606_14 14   DSS   7 day07         2
## DSSd07_3   DSSd07_3 KI_PC1606_15 15   DSS   7 day07         3
## &#39;data.frame&#39;:    6 obs. of  7 variables:
##  $ SampleName: chr  &quot;DSSd00_1&quot; &quot;DSSd00_2&quot; &quot;DSSd00_3&quot; &quot;DSSd07_1&quot; ...
##  $ SampleID  : chr  &quot;KI_PC1606_01&quot; &quot;KI_PC1606_02&quot; &quot;KI_PC1606_03&quot; &quot;KI_PC1606_13&quot; ...
##  $ No        : int  1 2 3 13 14 15
##  $ Model     : chr  &quot;DSS&quot; &quot;DSS&quot; &quot;DSS&quot; &quot;DSS&quot; ...
##  $ Day       : int  0 0 0 7 7 7
##  $ Group     : chr  &quot;day00&quot; &quot;day00&quot; &quot;day00&quot; &quot;day07&quot; ...
##  $ Replicate : int  1 2 3 1 2 3</code></pre>
<p>The most relevant metadata columns are <strong>sampleName</strong> and <strong>Group</strong>. It is important to check that the number of columns of data match the number of rows of metadata. And that the column names of data match the row names of metadata.</p>
<pre class="r"><code>all.equal(colnames(cr),rownames(mr))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Letâs visualise the distribution of counts using a boxplot and density plot.</p>
<pre class="r"><code>rafalib::mypar(1,2,mar=c(6,3,3,2))
boxplot(log2(as.matrix(cr)+1),
        ylab = expression(&#39;Log&#39;[2]~&#39;Read counts&#39;), las=2, main=&quot;Raw data&quot;)
hist(log2(as.matrix(cr)+1),
     ylab = &quot;&quot;, las = 2, main = &quot;Raw data&quot;)
par(mfrow=c(1,1))</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-13-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
<p>On the boxplot, the median values are zero across all samples. This means that half the values in each sample are zeros. On the histogram, we see a huge peak of zeros. This data set would benefit from a low count filtering.</p>
<p>We can check if any samples need to be discarded based on the number of genes detected. We create a barplot of genes detected across samples.</p>
<pre class="r"><code>barplot(colSums(cr&gt;3), ylab = &quot;Number of detected genes&quot;, las = 2)
abline(h = median(colSums(cr&gt;3)))</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-14-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
<p>On average, about 11502.00000 genes are detected. All samples are more or less close to the average. None of the samples look bad enough to be removed.</p>
<p><i class="fas fa-comments"></i> What does <code>cr&gt;3</code> do? Why did we use 3? Is it better than using <code>cr&gt;0</code>?</p>
<p>And we can create a similar plot for detection rate across genes.</p>
<pre class="r"><code>barplot(rowSums(cr&gt;3), xlab = &quot;Genes&quot;, ylab = &quot;Number of samples&quot;, names.arg = &quot;&quot;)
abline(h = median(rowSums(cr&gt;3)), col=&quot;red&quot;)</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-15-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
<p>This is hard to see. Itâs perhaps easier to plot a histogram.</p>
<pre class="r"><code>hist(rowSums(cr&gt;3))</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-16-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
<p>There are a lot of genes that are not expressed (ie; zero on x-axis) in any sample. These can be removed completely. We are mostly interested in the peak on the right. These are genes that are expressed in all samples. We donât want to be too stringent, so we will choose to keep genes that are expressed in at least 3 samples since our groups have 3 samples each.</p>
<p>Below, rather than using zero as the minimum value for detection, we used minimum of 5 reads in at least 3 samples (since each of test groups consist of 3 samples).</p>
<pre class="r"><code># remove genes with low counts
keep_genes &lt;- rowSums( cr &gt; 5 ) &gt;= 3
cf &lt;- cr[keep_genes,]</code></pre>
<p><i class="fas fa-comments"></i> How would the results change if we used total number of samples (ie; 6 for this dataset) in the code above? Are there any drawbacks to doing that?</p>
<p>Distribution of the filtered counts looks like below. Compare this to the previous boxplot above.</p>
<pre class="r"><code>boxplot(log2(as.matrix(cf)+1),ylab=expression(&#39;Log&#39;[2]~&#39;Read counts&#39;),las=2,main=&quot;Filtered data&quot;)</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-18-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
<p>In addition, compare the histogram of filtered counts below to the raw data above.</p>
<pre class="r"><code>hist(rowSums(cf&gt;3))</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-19-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
<p>The missingness in the data set is reduced. The filtering process has removed 44914 genes with low counts.</p>
<p>Since no samples were discarded, the metadata file will remain the same. And we can check that the labels are in the same order in counts and metadata.</p>
<pre class="r"><code>all.equal(colnames(cf),rownames(mr))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>At this point, we can save the filtered data.</p>
<pre class="r"><code>write.csv(cf, &quot;data/counts_filtered.csv&quot;, quote = F)</code></pre>
</div>
<div id="normalisation" class="section level1">
<h1><span class="header-section-number">3</span> Normalisation</h1>
<p>The raw count data needs to be corrected for various biases before statistical inference. If the dataset is to be used in an R package for differential gene expression such as <strong>DESeq2</strong>, <strong>edgeR</strong> or <strong>Limma</strong>, you must provide the <strong>raw data</strong> directly. This is because, these packages handle the correction and transformation internally. In addition, these packages do not control for gene length. Therefore, for custom analyses and gene-to-gene comparison, the raw data needs to be normalised.</p>
<div id="cpmtpm" class="section level2">
<h2><span class="header-section-number">3.1</span> CPM/TPM</h2>
<p>For analysis other than DGE, the data set must be corrected before use. The most basic correction required is sequencing depth. This is achieved using rescaling the counts to counts per 1 million (CPM).</p>
<pre class="r"><code>download_data(&quot;data/counts_filtered.csv&quot;)
cf &lt;- read.csv(&quot;data/counts_filtered.csv&quot;,
               stringsAsFactors = F,
               row.names = 1)

download_data(&quot;data/metadata_raw.csv&quot;)
if(!exists(&quot;mr&quot;)) mr &lt;- read.csv(&quot;data/metadata_raw.csv&quot;,
                                 stringsAsFactors=F,
                                 row.names=1)

all.equal(colnames(cf),rownames(mr))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>cc &lt;- t( t(cf) / colSums(cf) * 1e6 )
log2_cc &lt;- log2( cc + 1 )
boxplot(log2_cc,ylab=expression(&#39;Log&#39;[2]~&#39;Read counts&#39;),las=2,main=&quot;Log2 CPM&quot;)</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-23-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
<p>But, CPM data has some drawbacks. It is not suitable for within-sample comparisons. The total number of reads per sample varies from sample to sample. This also makes it harder to compare one experiment to another. In addition, gene length is not controlled for in this correction. RPKM/FPKM normalisations correct for gene length, but they are not recommended because they are not comparable between samples.</p>
<p>A better correction method that resolves sequencing depth and gene length is TPM (transcripts-per-million). The code for computing TPM is simple.</p>
<pre class="r"><code>#&#39; @title Compute TPM from a read count matrix
#&#39; @param counts A numeric data.frame of read counts with samples (columns) and genes (rows).
#&#39; @param len A vector of gene cds length equal to number of rows of dfr.
#&#39;
#&#39; https://support.bioconductor.org/p/91218/
#&#39;
tpm &lt;- function(counts,len) {
  x &lt;- counts/(len/1000)
  return(t(t(x)*1e6/colSums(x)))
}</code></pre>
<p>We read in the gene length information.</p>
<pre class="r"><code>co &lt;- read.delim(&quot;data/gene_counts_original.tsv&quot;,
                 sep=&quot;\t&quot;,
                 header=TRUE,
                 stringsAsFactors=F,
                 comment.char=&quot;#&quot;)
g &lt;- data.frame( ensembl_gene_id = co$Geneid , 
                 transcript_length = co$Length,
                 stringsAsFactors = F, row.names = co$Geneid)
g &lt;- g[!duplicated(g$ensembl_gene_id),]</code></pre>
<p>Next, we find shared genes between count data and annotation data and match their order.</p>
<pre class="r"><code>igenes &lt;- intersect(rownames(cf),g$ensembl_gene_id)
g1 &lt;- g[igenes,]
cf1 &lt;- cf[igenes,]
all.equal(rownames(cf1),g1$ensembl_gene_id)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>And then we run the <code>tpm()</code> function on the count data using the gene lengths. And then we create a boxplot of the resulting values.</p>
<pre class="r"><code>ct &lt;- tpm(cf1,g1$transcript_length)
log2_ct &lt;- log2( ct + 1 )
boxplot(log2_ct,ylab=expression(&#39;Log&#39;[2]~&#39;TPM&#39;),las=2,main=&quot;Log2 TPM&quot;)
write.csv(ct,&quot;data/counts_tpm.csv&quot;,quote=F)</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-27-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
<p>This is the distribution of TPM counts.</p>
</div>
<div id="deseq2" class="section level2">
<h2><span class="header-section-number">3.2</span> DESeq2</h2>
<p>DESeq2 internally corrects counts for sequencing depth and RNA compositional bias using <strong>Median of ratios</strong> method. The details of this method are described further in the DGE lab. To run this method, we create a DESeq2 object using the count data and metadata.</p>
<pre class="r"><code>library(DESeq2)
mr$Group &lt;- factor(mr$Group)
d &lt;- DESeqDataSetFromMatrix(countData=cf,colData=mr,design=~Group)
d &lt;- DESeq2::estimateSizeFactors(d,type=&quot;ratio&quot;)
cd &lt;- counts(d,normalized=TRUE)
saveRDS(cd,&quot;data/gene_counts_normalised_deseq2.Rds&quot;)</code></pre>
<pre class="r"><code>cd &lt;- readRDS(&quot;data/gene_counts_normalised_deseq2.Rds&quot;)
log2_cd &lt;- log2(cd + 1)
boxplot(log2_cd,ylab=expression(&#39;Log&#39;[2]~&#39;Read counts&#39;),las=2,main=&quot;DESeq2&quot;)</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-29-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
</div>
<div id="vst" class="section level2">
<h2><span class="header-section-number">3.3</span> VST</h2>
<p>For the purpose of exploratory analysis such as MDS, PCA, clustering etc, VST (variance-stabilizing-transformation) is recommended. VST is also run using DESeq2. As in the previous step, a DESeq2 object is created.</p>
<pre class="r"><code>library(DESeq2)
mr$Group &lt;- factor(mr$Group)
d &lt;- DESeqDataSetFromMatrix(countData=cf,colData=mr,design=~Group)
d &lt;- DESeq2::estimateSizeFactors(d,type=&quot;ratio&quot;)
d &lt;- DESeq2::estimateDispersions(d)
cv &lt;- as.data.frame(assay(varianceStabilizingTransformation(d,blind=T)),check.names=F)

#write.csv(cv,&quot;data/gene_counts_vst.csv&quot;,quote=FALSE)

boxplot(cv,ylab=expression(&#39;Log&#39;[2]~&#39;Read counts&#39;),las=2,main=&quot;VST&quot;)</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-30-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
<p>The effect of VST transformation can be clearly seen in a mean vs variance plot.</p>
<pre class="r"><code>rowVar &lt;- function(x) apply(x,1,var)
rafalib::mypar(mfrow=c(3,2))
plot(log2(rowMeans(cf)),log2(rowVar(cf)),
     xlab=&#39;Mean raw counts (log scale)&#39;,
     ylab=&#39;Variance raw counts (log scale)&#39;,
     main=&quot;Raw counts (filtered)&quot;,cex=.1)
plot(rowMeans(log2(cf +1)),rowVar(log2(cf +1)),
     xlab=&#39;Mean log-transformed counts&#39;,
     ylab=&#39;Variance log-transformed counts&#39;,
     main=&quot;Log-transformed counts&quot;,cex=.1)
plot(rowMeans(log2_cc),rowVar(log2_cc),
     xlab=&quot;Mean log CPM&quot;,
     ylab=&#39;Variance log CPM&#39;,main=&quot;Log CPM&quot;,cex=.1)
plot(rowMeans(log2_ct),rowVar(log2_ct),
     xlab=&quot;Mean log TPM&quot;,
     ylab=&#39;Variance log TPM&#39;,main=&quot;Log TPM&quot;,cex=.1)
plot(rowMeans(log2_cd),rowVar(log2_cd),
     xlab=&#39;Mean DESeq2&#39;,ylab=&#39;Variance DESeq2&#39;,main=&quot;DESeq2&quot;,cex=.1)
plot(rowMeans(cv),rowVar(cv),
     xlab=&#39;Mean VST-transformed&#39;,
     ylab=&#39;Variance VST-transformed&#39;,main=&quot;VST&quot;,cex=.1)
rafalib::mypar(mar=c(6,2.5,2.5,1))</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-31-1.svg" width="672" style="display: block; margin: auto auto auto 0;" /></p>
<p>For RNA-seq data, as the mean count value increases, the variance increases. There is a strong almost linear relationship as seen in the figures. The statistical methods such as PCA expects similar variance across the range of mean values. If not, the higher variance genes will contribute more than the lower variance genes. Such data is said to be heteroscedastic and needs to be corrected. One option is log transformation (with pseudocount), but this tends to inflate the contribution of the low variance genes. To obtain similar variance across the whole range of mean values, DESeq2 offers two methods VST (variance stabilising transformation) and RLOG (regularised log transformation).</p>
<p>As the name suggests, VST transformation stabilizes variance across the whole range of count values. VST is recommended for clustering or visualisation. It is not intended for differential gene expression. If the size factors vary dramatically between samples, then RLOG transformation is recommended. A comparable approach is voom transformation from the R package limma.</p>
</div>
<div id="conclusion" class="section level2">
<h2><span class="header-section-number">3.4</span> Conclusion</h2>
<p>Finally, we can compare all of the various transformations in a single plot.</p>
<pre class="r"><code>rafalib::mypar(1,4,mar=c(6,2.5,2.5,1) )
boxplot(as.matrix(log2(cc+1)),ylab=expression(&#39;Log&#39;[2]~&#39;Read counts&#39;),las=2,main=&quot;Log CPM&quot;, ylim = c(0,16))
boxplot(as.matrix(log2(ct+1)),ylab=expression(&#39;Log&#39;[2]~&#39;Read counts&#39;),las=2,main=&quot;Log TPM&quot;, ylim = c(0,16))
boxplot(as.matrix(log2(cd+1)),ylab=expression(&#39;Log&#39;[2]~&#39;Read counts&#39;),las=2,main=&quot;DESeq2&quot;, ylim = c(0,16))
boxplot(as.matrix(cv),ylab=expression(&#39;Log&#39;[2]~&#39;Read counts&#39;),las=2,main=&quot;VST&quot;, ylim = c(0,16))
rafalib::mypar(mar=c(6,2.5,2.5,1))</code></pre>
<p><img src="lab_preprocessing_files/figure-html/unnamed-chunk-32-1.svg" width="864" style="display: block; margin: auto auto auto 0;" /></p>
<p>At this point, we can save the filtered data.</p>
<pre class="r"><code># write.csv(cc,&quot;data/counts_cpm.csv&quot;,quote=F)
write.csv(ct,&quot;data/counts_tpm.csv&quot;,quote=F)
# write.csv(cd,&quot;data/counts_deseq2.csv&quot;,quote=F)
# write.csv(cv,&quot;data/counts_vst.csv&quot;,quote=F)</code></pre>
<p><i class="fas fa-comments"></i> Would it be possible to have one perfect normalisation method for all types of analyses? Is there any drawback to using gene length corrected counts in differential gene expression analyses?</p>
<hr />
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
